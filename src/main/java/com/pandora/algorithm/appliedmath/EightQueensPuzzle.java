package com.pandora.algorithm.appliedmath;/** * The eight queens puzzle is the problem of placing eight chess queens on an 8×8 chessboard * so that no two queens threaten each other. * Thus, a solution requires that no two queens share the same row, column, or diagonal. * The eight queens puzzle is an example of the more general n queens problem of placing n non-attacking queens * on an n×n chessboard, for which solutions exist for all natural numbers n with the exception * * Created by mordor on 17/6/22. */public class EightQueensPuzzle {    static final int queens = 8;    static Integer nextQueen = 0 ;    static String oldNextQueen = "";    static int[][] queensLocation = new int[queens][2];    static Integer pringNumber = 0 ;    static Integer rollback = 1;    public static void main(String[] args) {        compute();//        printChess();    }    public static void compute(){        nextqueen : for (;nextQueen < queens;){            int row = queensLocation[nextQueen][0];            int col = queensLocation[nextQueen][1];            //create checkerboard            for( ; row < queens ; row++){                for( ; col < queens ; col++){                    if(checkCompare(row, col) || nextQueen==0 ){                        queensLocation[nextQueen][0] = row;                        queensLocation[nextQueen][1] = col;//                        System.out.println("{" + queensLocation[nextQueen][0] + ", " + queensLocation[nextQueen][1] + "}");                        printChess();                        nextQueen++;                        continue nextqueen;                    }                }                col = 0 ;            }            //如果没有匹配数据 那么将上一步回退            rollback = lastcompare(oldNextQueen);            if(nextQueen>1) nextQueen-=rollback;            else return ;            oldNextQueen += "" + nextQueen;            for(int i = nextQueen ; i<queens ; i++){                queensLocation[i][0] = -1 ;                queensLocation[i][1] = -1 ;            }            queensLocation[nextQueen][0] = --queensLocation[nextQueen][0];            queensLocation[nextQueen][1] = --queensLocation[nextQueen][1];        }        System.out.println("----- result -------");        for (int i = 0 ; i < queens; i ++){            System.out.println("{" + queensLocation[i][0] + ", " + queensLocation[i][1] + "}");        }        printChess();    }    public static boolean checkCompare(int row, int col){        for (int i = 0 ; i <= nextQueen; i ++){            int row_ForwardSlash = queensLocation[i][0];            int col_ForwardSlash = queensLocation[i][1];            int row_Backslash = queensLocation[i][0];            int col_Backslash = queensLocation[i][1];            //行列之间都不能有重复            if(row == row_ForwardSlash || col == col_ForwardSlash){                return Boolean.FALSE;            }            //正反斜线之内也不能有重复            while(row_ForwardSlash>-1 && col_ForwardSlash>-1){                row_ForwardSlash--;                col_ForwardSlash--;            }            while(row_Backslash==0 || col_Backslash==0){                row_Backslash--;                col_Backslash++;            }            //正反斜线之内也不能有重复            while(row_ForwardSlash<queens && col_ForwardSlash<queens){                if(row == row_ForwardSlash && col == col_ForwardSlash){                    return Boolean.FALSE;                }                row_ForwardSlash++;                col_ForwardSlash++;            }            while(row_Backslash<queens && col_Backslash<queens){                if(row == row_Backslash && col == col_Backslash){                    return Boolean.FALSE;                }                row_Backslash++;                col_Backslash--;            }        }        return Boolean.TRUE;    }    public static void printChess(){        System.out.println("print number : [" + pringNumber++ + "] nextqueen ["+nextQueen+"] rollback["+rollback+"] oldNextQueen["+oldNextQueen+"] ");        for( int row = 0 ; row < queens ; row++){            for( int col = 0 ; col < queens ; col++) {                boolean bool = false ;                for(int i = 0 ; i < queens ; i++ ){                    if(row == queensLocation[i][0] && col == queensLocation[i][1]){                        bool = true;                    }                }                if(bool){                    System.out.print("X ");                }else                    System.out.print("+ ");            }            System.out.println();        }        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public static int lastcompare(String str){        int length = str.length();        for(int i = length/2 ; i < length ; i++){            String lastStr = str.substring(i);            if(str.endsWith(lastStr+lastStr)){                return i+1;            }        }        return 1;    }}